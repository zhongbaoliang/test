package javaee.thread;
/**
 * 用户级线程与内核级线程
 *内核线程：由操作系统内核创建和撤销。
 * 内核维护进程及线程的上下文信息以及线程切换。
 * 一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。
 * Windows NT和2000/XP支持内核线程。
 *
 * 内核级线程优点：当有多个处理机时，一个进程的多个线程可以同时执行。
 * 内核级线程缺点：由内核进行调度。
 *
 *
 * 用户线程：指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，
 * 应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
 * 不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，
 * 因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。
 * 由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。
 *  用户级线程优点：
 *  （1） 线程的调度不需要内核直接参与，控制简单。
 *  （2） 可以在不支持线程的操作系统中实现。
 *  （3） 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。
 *  （4） 允许每个进程定制自己的调度算法，线程管理比较灵活。
 *  （5） 线程能够利用的表空间和堆栈空间比内核级线程多。
 *  用户级线程缺点 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。
 *
 * */

/**
 * 三种线程模型：
 * 1对1
 * 创建一个用户线程就要创建一个相应的内核线程。
 * 由于创建内核线程的开销会影响应用程序的性能，所以这种模型的大多数实现限制了系统支持的线程数量。
 * Linux，还有 Windows 操作系统的家族，都实现了一对一模型。
 *
 * 1对多
 * 线程管理是由用户空间的线程库来完成的，因此效率更高。
 * 不过，如果一个线程执行阻塞系统调用，那么整个进程将会阻塞。
 * 再者，因为任一时间只有一个线程可以访问内核，所以多个线程不能并行运行在多处理核系统上。
 *
 * 多对多
 *内核控制线程:又称轻型进程lwp(light weight process)
 * 每一个进程可以拥有多个lwp,同用户级线程一样,每个lwp都有自己的数据结构如tcb(thread control block)，
 * lwp可以共享进程所有的资源。lwp不可能很大，是作为缓冲池。
 * 当用户级线程不需要与内核通信，便不需要与lwp连接
 *
 *1、java线程不是纯粹用户级线程：java中有个fork join框架，这个框架是利用多处理技术进行maprudce的工作，也就证明了内核是可以感知到用户线程的存在，因此才会将多个线程调度到多个处理器中。还有，java应用程序中的某个线程阻塞，是不会引起整个进程的阻塞，从这两点看，java线程绝不是纯粹的用户级线程。
 *2、java线程不是纯粹内核级线程：这点比较直观，如果使用纯粹的内核级线程，那么有关线程的所有管理工作都是内核完成的，用户程序中没有管理线程的代码。显然，java线程库提供了大量的线程管理机制，因此java线程绝不是纯粹的内核级线程。
 * 综上，java线程是混合型的线程模型，一般而言是通过lwp将用户级线程映射到内核线程中。
 *
 * */


public class JavaThread {

}
